{% extends "base.html" %}

{% block title %}{{ page_title }}{% endblock %}

{% block content %}
<div data-api-url="{{ api_url }}" 
     x-data="galleryApp($el.dataset.apiUrl)" 
     @scroll.window="handleScroll()"
     x-cloak>

    <div class="nav" :class="{ 'nav-hidden': !showNav }">
        <div class="nav-group left">
            {% if request.path.startswith('/folder/') %}
                <a href="#" @click.prevent="goBack()">â¬… è¿”å›ä¸Šçº§</a>
            {% elif request.path.startswith('/tags/random/') %}
                <a href="/tags">â¬… è¿”å›è§’è‰²</a>
            {% elif is_search %}
                {% if request.args.get('folder') %}
                    <a href="#" @click.prevent="goBack()">â¬… è¿”å›ä¸Šçº§</a>
                {% else %}
                    <a href="/tags">â¬… æ ‡ç­¾ç´¢å¼•</a>
                {% endif %}
            {% else %}
                <a href="/">ğŸ  é¦–é¡µ</a>
            {% endif %}
            
            <span style="color: #444;">|</span>
            <div class="nav-title" title="{{ page_title }}">{{ page_title }}</div>
            
            {% if not request.path.startswith('/tags/random/') and not is_search and not request.path.startswith('/folder/') %}
                <a href="/grid" x-show="!baseApiUrl.includes('/api/images')">å›¾ç‰‡</a>
                <a href="/videos" x-show="!baseApiUrl.includes('/api/videos')">è§†é¢‘</a>
                <a href="/tags">æ ‡ç­¾</a>
                <a href="/explore">ç›®å½•</a>
            {% endif %}
        </div>
        <div class="nav-group right">
            {% if not request.path.startswith('/tags/random/') and request.path != '/grid' and request.path != '/videos' %}
            <div class="filter-bar" style="margin-right: 15px;">
                <select class="filter-select" x-model="searchType" title="æœç´¢ç±»å‹">
                    <option value="tag">ğŸ·ï¸ æœæ ‡ç­¾</option>
                    <option value="char">ğŸ‘¤ æœè§’è‰²</option>
                </select>

                <div class="search-wrapper">
                    <input type="text" 
                           class="search-input" 
                           :placeholder="searchPlaceholder" 
                           x-model="searchQuery"
                           @input="handleInput()"
                           @keydown.arrow-down.prevent="navigateSuggestions(1)"
                           @keydown.arrow-up.prevent="navigateSuggestions(-1)"
                           @keydown.enter.prevent="handleEnter()"
                           @keydown.escape.prevent="suggestions = []; selectedIndex = -1"
                           id="gridSearchInput">
                    
                    <div class="autocomplete-list" 
                         x-show="suggestions.length > 0" 
                         @click.outside="suggestions = []; selectedIndex = -1">
                        <template x-for="(item, index) in suggestions" :key="index">
                            <div class="suggestion-item" 
                                 :class="{ 'active': selectedIndex === index }"
                                 @click="selectSuggestion(item)"
                                 @mouseover="selectedIndex = index">
                                <span x-text="item.name"></span>
                                <span class="count" x-text="item.count"></span>
                            </div>
                        </template>
                    </div>
                </div>

                <button class="search-btn" @click="performSearch()" style="padding: 0 10px;">ğŸ”</button>
            </div>
            {% endif %}

            {% if character_name %}
                <a href="/tags/folders/{{ character_name | urlencode }}" class="folder-btn" @click.prevent="window.location.replace($el.href)">ğŸ“‚ æ–‡ä»¶å¤¹æ¨¡å¼</a>
            {% elif is_search and search_query %}
                <a href="#" class="folder-btn" @click.prevent="toggleFolderMode()">ğŸ“‚ æ–‡ä»¶å¤¹æ¨¡å¼</a>
            {% endif %}
        </div>
    </div>

    <div class="grid-container">
		{% if subfolders %}
            {% for folder in subfolders %}
                <a href="{{ '/explore/' + folder.path if folder.has_sub else '/folder/' + folder.path }}" class="grid-item folder-card-in-grid">
                    <div class="char-cover">
                        {% if folder.has_img and folder.cover %}
                            <img src="/media/{{ folder.cover | replace('#', '%23') | replace('?', '%3F') }}" loading="lazy" onload="this.classList.add('loaded')">
                        {% elif folder.count > 0 %}
                            <div class="video-placeholder-cover">
                                <span>ğŸ¬<br><span style="font-size: 0.8em;">Video/GIF</span></span>
                            </div>
                        {% endif %}
                        <div class="char-overlay"></div>
                        {% if folder.has_sub %}
                            <div class="mobile-folder-hint">ğŸ“‚</div>
                        {% endif %}
                    </div>
                    <div class="char-info">
                        <div class="char-name">{{ folder.name }}</div>
                        <div class="char-count">{{ folder.count }} é¡¹å†…å®¹</div>
                    </div>
                </a>
            {% endfor %}
        {% endif %}
        <template x-for="(file, index) in items" :key="index">
            <div class="grid-item" @click="openModal(index)">
                <template x-if="isImage(file)">
					<img :src="'/media/' + encodePath(file)" loading="lazy" @load="$el.classList.add('loaded')">
				</template>
				<template x-if="isVideo(file)">
					<video :src="'/media/' + encodePath(file)" muted loop playsinline
						   onmouseover="this.play()" onmouseout="this.pause()"
						   onloadeddata="this.classList.add('loaded')"></video>
				</template>

                <div class="action-buttons-container" @click.stop>
                    <button class="action-btn tag-btn" 
                            title="æŸ¥çœ‹å›¾ç‰‡æ ‡ç­¾" 
                            @click.prevent="viewImageTags(file)">
                        ğŸ·ï¸
                    </button>

                    <a :href="getFolderLink(file)" 
                       class="action-btn folder-btn" 
                       title="æ‰“å¼€å›¾é›†"
                       x-show="!isFolderView && hasFolder(file)">
                        ğŸ“‚
                    </a>
                </div>
            </div>
        </template>

        <div class="loader-trigger" x-intersect="typeof loadMore === 'function' && loadMore()">
            <span x-show="loading">â³ åŠ è½½ä¸­...</span>
            <span x-show="!hasMore && items.length > 0">--- End ---</span>
        </div>
    </div>
	
	<div class="modal tags-modal" 
         x-show="tagsModalOpen" 
         x-transition.opacity
         @keydown.escape.window="closeTagsModal()"
         @click="closeTagsModal()"
         x-cloak>
         
        <div class="tags-modal-box" @click.stop>
            <div class="tags-modal-header">
                <h3>ğŸ·ï¸ å›¾ç‰‡æ ‡ç­¾å±æ€§</h3>
                <div class="tags-modal-close" @click="closeTagsModal()">&times;</div>
            </div>
            
            <div class="tags-search-area">
                <input type="text" 
                       x-model="tagSearchQuery" 
                       placeholder="ç‚¹å‡»ä¸‹æ–¹æ ‡ç­¾ç»„åˆæœç´¢ (ä»¥é€—å·åˆ†éš”)..." 
                       @keydown.enter="performTagSearch()">
                <button class="search-btn" @click="performTagSearch()">ğŸ” æœç´¢</button>
            </div>
            
            <div class="tags-list-area">
                <div x-show="loadingTags" class="tags-status-text">â³ æ­£åœ¨ä»æ•°æ®åº“è¯»å–æ ‡ç­¾...</div>
                <div x-show="!loadingTags && currentImageTags.length === 0" class="tags-status-text">è¿™å¼ å›¾ç‰‡ä¼¼ä¹è¿˜æ²¡æœ‰æ‰“ä¸Šæ ‡ç­¾å“¦~</div>
                
                <div class="tag-cloud">
                    <template x-for="(tag, index) in currentImageTags" :key="index">
                        <span class="tag-badge" 
                              :style="getTagColor(tag)"
                              @click="appendTagToSearch(tag)"
                              x-text="tag"></span>
                    </template>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" 
         x-show="modalOpen" 
         x-transition.opacity
         @keydown.escape.window="closeModal()"
         @keydown.arrow-right.window="next()"
         @keydown.arrow-left.window="prev()"
         @click="closeModal()">
         
        <div class="modal-close" @click.stop="closeModal()">&times;</div>
        
        <div style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;">
            <template x-if="modalOpen && currentItem">
                <div class="modal-media-container" 
                     @click.stop 
                     @touchstart="touchStartX = $event.changedTouches[0].screenX; touchStartY = $event.changedTouches[0].screenY"
                     @touchend="handleSwipe($event)">
                     
                    <div class="nav-hitbox prev-hitbox" @click.stop="prev()"></div>
                    <div class="nav-hitbox next-hitbox" @click.stop="next()"></div>

                    <template x-if="isImage(currentItem)">
                        <img :src="'/media/' + encodePath(currentItem)" class="modal-content">
                    </template>
                    <template x-if="isVideo(currentItem)">
                        <video :src="'/media/' + encodePath(currentItem)" class="modal-content" controls autoplay loop playsinline muted></video>
                    </template>
                </div>
            </template>
        </div>
    </div>
</div>

<style>
.nav a.folder-btn {
    background-color: #005a9e;
    color: #fff;
    font-weight: bold;
}
.nav a {
    color: #eee;
    text-decoration: none;
    padding: 0 15px;
    font-size: 14px;
    height: 100%;
    display: flex;
    align-items: center;
    white-space: nowrap;
    background-color: transparent;
    transition: background-color 0.2s;
}
/* æ··æ’æ¨¡å¼ä¸‹çš„æ–‡ä»¶å¤¹å¡ç‰‡æ ·å¼ */
.folder-card-in-grid {
	text-decoration: none; display: block;
	border-radius: 4px; border: 1px solid #333;
	transition: transform 0.2s, border-color 0.2s;
}
.folder-card-in-grid:hover {
	transform: translateY(-5px); border-color: #0078d4;
	box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 10;
}
.folder-card-in-grid .char-cover { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
.folder-card-in-grid .char-cover img { width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.5s; }
.folder-card-in-grid .char-cover img.loaded { opacity: 1; }
.folder-card-in-grid .char-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 60%; background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); z-index: 1; }
.folder-card-in-grid .char-info { position: absolute; bottom: 0; left: 0; width: 100%; padding: 12px; box-sizing: border-box; z-index: 2; }
.folder-card-in-grid .char-name { color: #fff; font-weight: bold; font-size: 1.1em; text-shadow: 0 1px 2px rgba(0,0,0,1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
.folder-card-in-grid .char-count { color: #ccc; font-size: 0.85em; }
.folder-card-in-grid .mobile-folder-hint { position: absolute; bottom: 60px; right: 10px; width: 32px; height: 32px; background-color: rgba(0, 0, 0, 0.65); backdrop-filter: blur(4px); border: 1px solid rgba(255, 255, 255, 0.25); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 20; }
.folder-card-in-grid .video-placeholder-cover { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #2a2a2a; color: #888; text-align: center; font-size: 1.2em; line-height: 1.2; }

@media (max-width: 768px) {
	.folder-card-in-grid .char-info { padding: 6px !important; }
	.folder-card-in-grid .char-name { font-size: 0.8em !important; margin-bottom: 2px !important; }
	.folder-card-in-grid .char-count { font-size: 0.7em !important; }
	.folder-card-in-grid .mobile-folder-hint { width: 24px; height: 24px; font-size: 14px; bottom: 45px; right: 4px; }
}

/* --- æœç´¢æ æ ·å¼ï¼ˆåŒæ­¥è‡ª explore/tagsï¼‰ --- */
.filter-bar { display: flex; align-items: center; gap: 8px; height: 32px; }
.filter-select { 
	background-color: #333; color: #eee; border: 1px solid #555; 
	padding: 0 24px 0 10px; border-radius: 4px; font-size: 12px; height: 100%;
	appearance: none; 
	background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
	background-repeat: no-repeat; background-position: right 5px center; background-size: 12px;
}
.search-wrapper { position: relative; height: 100%; }
.search-input { 
	background: #222; border: 1px solid #444; color: #fff; 
	padding: 0 10px; border-radius: 4px; width: 140px; height: 100%;
	transition: width 0.3s; font-size: 13px; box-sizing: border-box;
}
.search-input:focus { width: 200px; border-color: #0078d4; outline: none; }

.autocomplete-list { 
	position: absolute; top: 110%; left: 0; min-width: 100%; 
	background: #1e1e1e; border: 1px solid #444; border-radius: 4px; 
	max-height: 250px; overflow-y: auto; z-index: 2000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); 
	text-align: left; /* ä¿®æ­£å¯èƒ½è¢«å¤–éƒ¨ç»§æ‰¿çš„å±…ä¸­å¯¹é½ */
}
.suggestion-item { 
	padding: 8px 12px; border-bottom: 1px solid #333; cursor: pointer; 
	display: flex; justify-content: space-between; color: #ddd; font-size: 12px;
}
.suggestion-item.active, .suggestion-item:hover { background: #0078d4; color: #fff; }
.suggestion-item .count { color: #666; font-size: 0.9em; }

.search-btn {
	height: 100%; padding: 0 12px; background-color: #0078d4; color: white; border: none;
	border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;
	transition: background 0.2s, transform 0.1s; display: flex; align-items: center; justify-content: center;
	box-shadow: none !important;
}
.search-btn:hover { background-color: #0063b1; }
.search-btn:active { transform: scale(0.96); }

/* ç§»åŠ¨ç«¯é€‚é…ï¼šç¼©å°æœç´¢æ¡†å’Œéšè—åˆ†ç±»é€‰æ‹©ä»¥èŠ‚çœç©ºé—´ */
@media (max-width: 768px) {
	.filter-select { display: none; }
	.search-input { width: 100px; }
	.search-input:focus { width: 140px; }
	.filter-bar { margin-right: 5px !important; }
}

.action-buttons-container {
	position: absolute;
	bottom: 8px;
	right: 8px;
	display: flex;
	flex-direction: column; /* ğŸ‘ˆ ã€æ ¸å¿ƒä¿®æ”¹ã€‘ï¼šæ”¹ä¸ºç«–å‘æ’åˆ— */
	gap: 8px;
	opacity: 0; /* PCç«¯é»˜è®¤éšè— */
	transition: opacity 0.2s ease-in-out;
	z-index: 10;
}

/* PCç«¯ï¼šé¼ æ ‡æ‚¬æµ®åœ¨æ•´ä¸ªå›¾ç‰‡å¡ç‰‡ä¸Šæ—¶ï¼Œæ˜¾ç¤ºæŒ‰é’®ç»„ */
.grid-item:hover .action-buttons-container {
	opacity: 1;
}

/* ç»Ÿä¸€çš„åœ†å½¢ç£¨ç ‚æ‚¬æµ®æŒ‰é’®æ ·å¼ */
.action-btn {
	width: 32px;
	height: 32px;
	background-color: rgba(0, 0, 0, 0.65);
	backdrop-filter: blur(4px);
	border: 1px solid rgba(255, 255, 255, 0.25);
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 16px;
	color: white;
	text-decoration: none;
	cursor: pointer;
	transition: transform 0.1s, background-color 0.2s;
	padding: 0;
}

.action-btn:hover {
	background-color: rgba(0, 120, 212, 0.9);
	transform: scale(1.1);
}

/* ç§»åŠ¨ç«¯æ·±åº¦é€‚é… */
@media (max-width: 768px) {
	.action-buttons-container {
		/* æ‰‹æœºç«¯ä¿æŒå¸¸é©»æ˜¾ç¤ºï¼Œä¸ä¾èµ– hover */
		opacity: 1; 
		bottom: 6px; /* ç¨å¾®ç•™ä¸€ç‚¹è¾¹è· */
		right: 6px;
		gap: 8px; /* ç«–å‘æŒ‰é’®ä¹‹é—´ä¿ç•™ä¸€ç‚¹ç©ºéš™é˜²è¯¯è§¦ */
	}
	
	/* ã€å·²åˆ é™¤éšè— tag-btn çš„ä»£ç ï¼Œç°åœ¨ç§»åŠ¨ç«¯ä¹Ÿä¼šæ˜¾ç¤ºæ ‡ç­¾æŒ‰é’®ã€‘ */

	.action-btn {
		width: 30px; /* å°ºå¯¸æ¯”åˆšæ‰çš„ 28px ç¨å¾®å¤§ä¸€ç‚¹ï¼Œæå‡æ‰‹æ„Ÿ */
		height: 30px;
		font-size: 14px;
	}
}

/* =========================================
   æ ‡ç­¾æ¨¡æ€æ¡†æ ·å¼ (å®Œå…¨ä¿®å¤ç‰ˆ)
   ========================================= */
.tags-modal { 
    z-index: 3000; align-items: center; padding: 20px; 
    box-sizing: border-box; /* ç¡®ä¿ padding ä¸ä¼šå¯¼è‡´å¤–å±‚å˜å¤§ */
}
.tags-modal-box { 
    background: #1e1e1e; border: 1px solid #444; border-radius: 12px; 
    width: 100%; max-width: 600px; padding: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); 
    max-height: 90vh; 
    display: flex; 
    flex-direction: column;
    box-sizing: border-box;
}

/* é˜²æ­¢å¤´éƒ¨å’Œæœç´¢åŒºè¢«å‹ç¼© */
.tags-modal-header { 
    display: flex; justify-content: space-between; align-items: center; 
    margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 12px; 
    flex-shrink: 0; 
}
.tags-modal-header h3 { margin: 0; font-size: 1.2em; color: #fff; }
.tags-modal-close { font-size: 28px; cursor: pointer; color: #888; transition: color 0.2s; line-height: 1; margin-top: -4px; }
.tags-modal-close:hover { color: #fff; }

.tags-search-area { 
    display: flex; gap: 10px; margin-bottom: 20px; 
    flex-shrink: 0; /* é˜²æ­¢è¢«æŒ¤å‹ */
}
.tags-search-area input { 
    flex: 1; background: #111; border: 1px solid #555; color: #fff; 
    padding: 12px 15px; border-radius: 6px; font-size: 14px; 
    box-sizing: border-box;
}
.tags-search-area input:focus { border-color: #0078d4; outline: none; }
.tags-search-area .search-btn {
    font-size: 14px;
    padding: 12px 28px; 
    font-weight: 600;
    cursor: pointer;
    height: auto; 
    line-height: normal;
    border-radius: 6px; 
    box-sizing: border-box; /* æ ¸å¿ƒä¿®å¤ï¼šé˜²æ­¢ padding æ’‘ç ´å®¹å™¨ */
}

/* åˆ é™¤äº†é‡å¤çš„æ—§ä»£ç ï¼Œä¿ç•™è‡ªé€‚åº”å¡«æ»¡å‰©ä½™ç©ºé—´å¹¶æ»šåŠ¨çš„é€»è¾‘ */
.tags-list-area { 
    flex: 1; 
    min-height: 150px; 
    overflow-y: auto; 
    padding-right: 5px; 
}
.tags-status-text { color: #888; text-align: center; padding: 40px 0; font-size: 0.95em; }
.tag-cloud { display: flex; flex-wrap: wrap; gap: 10px; }

/* æ ‡ç­¾åŠ¨ç”» */
.tag-badge { 
    padding: 6px 14px; border-radius: 20px; font-size: 13px; color: #fff; 
    cursor: pointer; user-select: none; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    text-shadow: 0 1px 2px rgba(0,0,0,0.8); 
    transition: filter 0.2s, box-shadow 0.2s; 
    position: relative;
}
.tag-badge:hover { 
    filter: brightness(1.3); 
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.7), 0 0 10px rgba(255,255,255,0.6);
    z-index: 1;
}
.tag-badge:active { 
    filter: brightness(0.9); 
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); 
}

/* =========================================
   ç§»åŠ¨ç«¯ä¸“å±è¦†ç›–
   ========================================= */
@media (max-width: 768px) {
    .tags-modal { 
        padding: 10px; 
    }
    .tags-modal-box { 
        padding: 15px; 
        max-height: 95vh; 
    }
    .tags-modal-header {
        margin-bottom: 15px;
        padding-bottom: 10px;
    }
    .tags-search-area {
        flex-direction: column; 
        gap: 10px;
        margin-bottom: 15px;
    }
    .tags-search-area input {
        width: 100%;
    }
    .tags-search-area .search-btn {
        width: 100%; 
        padding: 12px;
        display: flex;
        justify-content: center;
    }
    .tag-badge {
        font-size: 12px; 
        padding: 6px 12px;
    }
}
</style>

<script>
function galleryApp(apiUrl) {
    // é¢„å¤„ç†ï¼šç¡®ä¿ä¼ å…¥çš„ URL å­—ç¬¦ä¸²ä¸å¸¦å¤šä½™çš„å¼•å·ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ï¼‰
    const cleanApiUrl = typeof apiUrl === 'string' ? apiUrl.replace(/^["']|["']$/g, '') : '';

    return {
        items: [],
        page: 1,
        loading: false,
        hasMore: true,
        modalOpen: false,
        currentIndex: 0,
        baseApiUrl: cleanApiUrl,
        isFolderView: cleanApiUrl.includes('folder_data') {% if not is_search and request.args.get('folder') and has_subfolders is defined and not has_subfolders %} || true {% endif %},
        seed: (cleanApiUrl.includes('/api/images') || cleanApiUrl.includes('/api/videos')) ? Date.now() : null,
		searchQuery: {{ request.args.get('q', '') | tojson }},
        searchType: 'tag',
        allTags: [],
        suggestions: [],
        selectedIndex: -1,
        
        showNav: true,
        lastScrollY: 0,
		
		tagsModalOpen: false,
        loadingTags: false,
        currentImageTags: [],
        tagSearchQuery: '',
		
		touchStartX: 0,
        touchStartY: 0,
		
		init() {
            // ç»„ä»¶åŠ è½½æ—¶é¢„å–æ ‡ç­¾æ•°æ®ç”¨äºè¡¥å…¨
            this.loadTagsCache();
        },

        handleScroll() {
            if (this.modalOpen) return;
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
            this.showNav = !(currentScrollY > this.lastScrollY && currentScrollY > 50);
            this.lastScrollY = currentScrollY;
        },

        async loadMore() {
            if (this.loading || !this.hasMore) return;
            this.loading = true;
            try {
                const sep = this.baseApiUrl.includes('?') ? '&' : '?';
                let url = `${this.baseApiUrl}${sep}page=${this.page}`;
                if (this.seed) url += `&seed=${this.seed}`;
                
                const res = await fetch(url);
                if (!res.ok) throw new Error('Network response was not ok');
                const data = await res.json();
                
                if (data.files && data.files.length > 0) {
                    this.items.push(...data.files);
                    this.page++;
                    this.hasMore = data.has_more;
                } else {
                    this.hasMore = false;
                }
            } catch (e) {
                console.error("Gallery Load Error:", e);
                this.hasMore = false;
            } finally {
                this.loading = false;
            }
        },
		
		// 1. æ‰“å¼€æ ‡ç­¾é¢æ¿å¹¶è¯·æ±‚æ•°æ®
        async viewImageTags(file) {
            this.tagsModalOpen = true;
            this.loadingTags = true;
            this.currentImageTags = [];
            this.tagSearchQuery = ''; // æ¯æ¬¡æ‰“å¼€æ¸…ç©ºæœç´¢æ¡†
            
            try {
                // å‘åç«¯è¯·æ±‚è¯¥å›¾ç‰‡çš„æ‰€æœ‰ Tags
                const res = await fetch('/api/image_tags?path=' + encodeURIComponent(file));
                const tags = await res.json();
                this.currentImageTags = tags;
            } catch (e) {
                console.error("åŠ è½½å›¾ç‰‡æ ‡ç­¾å¤±è´¥:", e);
            } finally {
                this.loadingTags = false;
            }
        },

        // 2. å…³é—­é¢æ¿
        closeTagsModal() {
            this.tagsModalOpen = false;
        },

        // 3. å°†ç‚¹å‡»çš„ tag ä¼˜é›…åœ°æ‹¼æ¥åˆ°æœç´¢æ¡†
        appendTagToSearch(tag) {
            if (this.tagSearchQuery) {
                const endsWithComma = this.tagSearchQuery.trim().endsWith(',');
                this.tagSearchQuery += endsWithComma ? ` ${tag}, ` : `, ${tag}, `;
            } else {
                this.tagSearchQuery = `${tag}, `;
            }
        },

        // 4. æ‰§è¡Œè·³è½¬æœç´¢ (é»˜è®¤è¿›å…¥æ–‡ä»¶å¤¹æ¨¡å¼)
        performTagSearch() {
            const queryRaw = this.tagSearchQuery.trim().replace(/,$/, ''); 
            if (!queryRaw) return;
            
            // æ„å»ºå¸¦å‚æ•°çš„è·³è½¬ URLï¼Œå¼ºåˆ¶è·³è½¬åˆ° search/folders
            const url = `/search/folders?q=${encodeURIComponent(queryRaw)}`;
            window.location.href = url;
        },

        // 5. æ ¸å¿ƒé­”æ³•ï¼šæ ¹æ®å­—ç¬¦ä¸²ç”Ÿæˆç¨³å®šä¸”å¥½çœ‹çš„éšæœºè‰²ï¼
        getTagColor(tag) {
            let hash = 0;
            // é€šè¿‡å­—ç¬¦ä¸²è®¡ç®—å‡ºä¸€ä¸ªç¨³å®šçš„ Hash æ•£åˆ—å€¼
            for (let i = 0; i < tag.length; i++) {
                hash = tag.charCodeAt(i) + ((hash << 5) - hash);
            }
            // å°† Hash æ˜ å°„åˆ° 0-360 çš„è‰²ç›¸è§’ (Hue)
            const h = Math.abs(hash) % 360;
            // é¥±å’Œåº¦ 65%ï¼Œäº®åº¦ 45%ï¼Œè¾…ä»¥å¾®é€æ˜ï¼Œä¿è¯æ–‡å­—æ¸…æ™°å’Œè‰²å½©é²œè‰³
            return `background-color: hsla(${h}, 65%, 45%, 0.85); border: 1px solid hsla(${h}, 65%, 55%, 0.9);`;
        },
		
		goBack() {
            // å¦‚æœæœ‰å®Œæ•´çš„å†å²è®°å½•ï¼Œå®Œç¾é€€å›ä¸Šä¸€ä¸ªé¡µé¢ï¼ˆèƒ½ä¿ç•™ä½ çœ‹å›¾çš„æ»šåŠ¨ä½ç½®ï¼‰
            if (window.history.length > 1 && document.referrer.includes(window.location.host)) {
                window.history.back(); 
            } else {
                // ã€æ ¸å¿ƒå…œåº•ä¼˜åŒ–ã€‘ï¼šæ²¡æœ‰å†å²è®°å½•æ—¶çš„å¼ºåˆ¶å¯»è·¯
                if (this.baseApiUrl.includes('folder_data')) {
                    // 1. å¦‚æœå½“å‰åœ¨æ–‡ä»¶å¤¹é‡Œï¼Œå¼ºè¡Œé€€å›ä¸Šä¸€çº§ç›®å½•
                    let currentFolder = decodeURIComponent(window.location.pathname.replace('/folder/', ''));
                    let parts = currentFolder.split('/');
                    parts.pop(); // ç æ‰æœ€åä¸€å±‚
                    if (parts.length > 0 && parts[0] !== '') {
                        window.location.href = '/explore/' + parts.map(encodeURIComponent).join('/');
                    } else {
                        window.location.href = '/explore'; 
                    }
                } else if (window.location.search.includes('folder=')) {
                    // 2. å¦‚æœå½“å‰åœ¨æŸæ–‡ä»¶å¤¹çš„æœç´¢ç»“æœä¸­ï¼Œå¼ºè¡Œé€€å›è¯¥æ–‡ä»¶å¤¹ï¼
                    const urlParams = new URLSearchParams(window.location.search);
                    const folder = urlParams.get('folder');
                    window.location.href = '/folder/' + folder.split('/').map(encodeURIComponent).join('/');
                } else {
                    // 3. å…¨å±€æœç´¢ç­‰å…¶ä»–æƒ…å†µ
                    window.location.href = '/tags';
                }
            }
        },
		
		// åŠ¨æ€åˆ¤å®šæœç´¢æç¤ºå ä½ç¬¦
        get searchPlaceholder() {
            if (window.location.pathname.startsWith('/folder/') || new URLSearchParams(window.location.search).get('folder')) {
                return "åœ¨æ­¤ç›®å½•ä¸‹æœç´¢...";
            }
            return "å…¨åº“æœç´¢...";
        },

        async loadTagsCache() {
            try {
                const res = await fetch('/api/tags/all');
                this.allTags = await res.json();
            } catch(e) { console.error("Tags cache error", e); }
        },

        handleInput() {
            this.selectedIndex = -1;
            const val = this.searchQuery;
            const parts = val.split(',');
            const lastPart = parts[parts.length - 1].trim().toLowerCase();

            if (lastPart.length < 1) {
                this.suggestions = [];
                return;
            }
            this.suggestions = this.allTags
                .filter(t => t.name.toLowerCase().includes(lastPart))
                .slice(0, 10);
        },

        navigateSuggestions(direction) {
            if (this.suggestions.length === 0) return;
            this.selectedIndex += direction;
            if (this.selectedIndex < 0) this.selectedIndex = this.suggestions.length - 1;
            else if (this.selectedIndex >= this.suggestions.length) this.selectedIndex = 0;
            
            this.$nextTick(() => {
                const activeEl = document.querySelector('.suggestion-item.active');
                if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
            });
        },

        handleEnter() {
            if (this.suggestions.length > 0 && this.selectedIndex >= 0) {
                this.selectSuggestion(this.suggestions[this.selectedIndex]);
            } else {
                this.performSearch();
            }
        },

        selectSuggestion(item) {
            let current = this.searchQuery;
            const parts = current.split(',');
            const newTagName = (item.type === 'char') ? `char:${item.name.replace('char:', '')}` : item.name;
            parts[parts.length - 1] = ' ' + newTagName; 
            this.searchQuery = parts.join(',') + ', ';
            
            this.suggestions = [];
            this.selectedIndex = -1;
            
            this.$nextTick(() => {
                const input = document.getElementById('gridSearchInput');
                if (input) {
                    input.focus();
                    const len = input.value.length;
                    input.setSelectionRange(len, len);
                }
            });
        },

		performSearch() {
            const queryRaw = this.searchQuery.trim().replace(/,$/, ''); 
            if (!queryRaw) return;
            
            let query = queryRaw;
            if (this.searchType === 'char' && !query.startsWith('char:')) {
                query = 'char:' + query;
            }

            let url = `/search?q=${encodeURIComponent(query)}`;
            const urlParams = new URLSearchParams(window.location.search);
            let folderContext = urlParams.get('folder');
            
            if (window.location.pathname.startsWith('/folder/')) {
                folderContext = decodeURIComponent(window.location.pathname.replace('/folder/', ''));
            }

            if (folderContext) {
                url += `&folder=${encodeURIComponent(folderContext)}`;
            }

            // ã€æ ¸å¿ƒä¿®å¤ã€‘ï¼šå¦‚æœå·²ç»åœ¨æœç´¢é¡µï¼Œåˆ™æ›¿æ¢å½“å‰å†å²è®°å½•ï¼›å¦åˆ™å‹å…¥æ–°å†å²
            if (window.location.pathname.startsWith('/search')) {
                window.location.replace(url);
            } else {
                window.location.href = url;
            }
        },

        openModal(idx) {
            this.currentIndex = idx;
            this.modalOpen = true;
            this.showNav = false;
            document.body.style.overflow = 'hidden';
        },
        closeModal() {
            this.modalOpen = false;
            this.showNav = true;
            document.body.style.overflow = '';
        },
        get currentItem() { return this.items[this.currentIndex]; },
        
        next() {
            if (this.currentIndex < this.items.length - 1) {
                this.currentIndex++;
            } else if (this.hasMore) {
                this.loadMore().then(() => {
                    if (this.currentIndex < this.items.length - 1) this.currentIndex++;
                });
            }
        },
        prev() { 
            if (this.currentIndex > 0) this.currentIndex--; 
        },
        isImage(p) { return p ? /\.(png|jpg|jpeg|webp|bmp|gif)$/i.test(p) : false; },
        isVideo(p) { return p ? /\.(mp4|webm|mov|mkv)$/i.test(p) : false; },
        hasFolder(p) { return p && (p.includes('/') || p.includes('\\')); },
		getFolderLink(p) {
            if (!p) return '#';
            const norm = p.replace(/\\/g, '/');
            const lastSlash = norm.lastIndexOf('/');
            return lastSlash !== -1 ? '/folder/' + encodeURIComponent(norm.substring(0, lastSlash)) : '#';
        },
		
		encodePath(p) {
            if (!p) return '';
            return p.split('/').map(encodeURIComponent).join('/');
        },
		
		handleSwipe(e) {
            const endX = e.changedTouches[0].screenX;
            const endY = e.changedTouches[0].screenY;
            const diffX = this.touchStartX - endX;
            const diffY = this.touchStartY - endY;
            
            // åˆ¤å®šï¼šå¿…é¡»æ˜¯æ¨ªå‘æ»‘åŠ¨ï¼ˆXè½´ä½ç§»å¤§äºYè½´ä½ç§»ï¼‰ï¼Œä¸”æ»‘åŠ¨è·ç¦»è¶…è¿‡ 40 åƒç´ ï¼Œé˜²æ­¢è¯¯è§¦
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 40) {
                if (diffX > 0) {
                    this.next(); // å‘å·¦åˆ’ï¼Œçœ‹ä¸‹ä¸€å¼ 
                } else {
                    this.prev(); // å‘å³åˆ’ï¼Œçœ‹ä¸Šä¸€å¼ 
                }
            }
        },
        
        // ã€æ–°å¢ã€‘ï¼šæ™ºèƒ½åˆ‡æ¢åˆ°æ–‡ä»¶å¤¹æ¨¡å¼ï¼Œä¿ç•™ä½œè€…ç›®å½•è¿‡æ»¤
        toggleFolderMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const q = urlParams.get('q');
            const folder = urlParams.get('folder');

            if (q) {
                let targetUrl = `/search/folders?q=${encodeURIComponent(q)}`;
                // å¦‚æœå½“å‰åœ¨ç‰¹å®šä½œè€…ç›®å½•ä¸‹æœç´¢ï¼Œå¿…é¡»å¸¦ä¸Š folder å‚æ•°
                if (folder) {
                    targetUrl += `&folder=${encodeURIComponent(folder)}`;
                }
                window.location.replace(targetUrl);
            } else {
                window.location.replace('/tags');
            }
        }
    }
}
</script>
{% endblock %}