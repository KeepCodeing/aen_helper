{% extends "base.html" %}

{% block title %}{{ page_title }}{% endblock %}

{% block content %}
<div data-api-url="{{ api_url }}" 
     x-data="galleryApp($el.dataset.apiUrl)" 
     @scroll.window="handleScroll()"
     x-cloak>

    <div class="nav" :class="{ 'nav-hidden': !showNav }">
        <div class="nav-group left">
            {% if request.path.startswith('/folder/') %}
                <a href="#" @click.prevent="goBack()">â¬… è¿”å›ä¸Šçº§</a>
            {% elif request.path.startswith('/tags/random/') %}
                <a href="/tags">â¬… è¿”å›è§’è‰²</a>
            {% elif is_search %}
                {% if request.args.get('folder') %}
                    <a href="#" @click.prevent="goBack()">â¬… è¿”å›ä¸Šçº§</a>
                {% else %}
                    <a href="/tags">â¬… æ ‡ç­¾ç´¢å¼•</a>
                {% endif %}
            {% else %}
                <a href="/">ğŸ  é¦–é¡µ</a>
            {% endif %}
            
            <span style="color: #444;">|</span>
            <div class="nav-title" title="{{ page_title }}">{{ page_title }}</div>
            
            {% if not request.path.startswith('/tags/random/') and not is_search and not request.path.startswith('/folder/') %}
                <a href="/grid" x-show="!baseApiUrl.includes('/api/images')">å›¾ç‰‡</a>
                <a href="/videos" x-show="!baseApiUrl.includes('/api/videos')">è§†é¢‘</a>
                <a href="/tags">æ ‡ç­¾</a>
                <a href="/explore">ç›®å½•</a>
            {% endif %}
        </div>
        <div class="nav-group right">
            {% if not request.path.startswith('/tags/random/') and request.path != '/grid' and request.path != '/videos' %}
            <div class="filter-bar" style="margin-right: 15px;">
                <select class="filter-select" x-model="searchType" title="æœç´¢ç±»å‹">
                    <option value="tag">ğŸ·ï¸ æœæ ‡ç­¾</option>
                    <option value="char">ğŸ‘¤ æœè§’è‰²</option>
                </select>

                <div class="search-wrapper">
                    <input type="text" 
                           class="search-input" 
                           :placeholder="searchPlaceholder" 
                           x-model="searchQuery"
                           @input="handleInput()"
                           @keydown.arrow-down.prevent="navigateSuggestions(1)"
                           @keydown.arrow-up.prevent="navigateSuggestions(-1)"
                           @keydown.enter.prevent="handleEnter()"
                           @keydown.escape.prevent="suggestions = []; selectedIndex = -1"
                           id="gridSearchInput">
                    
                    <div class="autocomplete-list" 
                         x-show="suggestions.length > 0" 
                         @click.outside="suggestions = []; selectedIndex = -1">
                        <template x-for="(item, index) in suggestions" :key="index">
                            <div class="suggestion-item" 
                                 :class="{ 'active': selectedIndex === index }"
                                 @click="selectSuggestion(item)"
                                 @mouseover="selectedIndex = index">
                                <span x-text="item.name"></span>
                                <span class="count" x-text="item.count"></span>
                            </div>
                        </template>
                    </div>
                </div>

                <button class="search-btn" @click="performSearch()" style="padding: 0 10px;">ğŸ”</button>
            </div>
            {% endif %}

            {% if character_name %}
                <a href="/tags/folders/{{ character_name | urlencode }}" class="folder-btn" @click.prevent="window.location.replace($el.href)">ğŸ“‚ æ–‡ä»¶å¤¹æ¨¡å¼</a>
            {% elif is_search and search_query %}
                {% if not request.args.get('folder') or (has_subfolders is defined and has_subfolders) %}
                <a href="#" class="folder-btn" @click.prevent="toggleFolderMode()">ğŸ“‚ æ–‡ä»¶å¤¹æ¨¡å¼</a>
                {% endif %}
            {% endif %}
        </div>
    </div>

    <div class="grid-container">
		{% if subfolders %}
            {% for folder in subfolders %}
                <a href="{{ '/explore/' + folder.path if folder.has_sub else '/folder/' + folder.path }}" class="grid-item folder-card-in-grid">
                    <div class="char-cover">
                        {% if folder.has_img and folder.cover %}
                            <img src="/media/{{ folder.cover | replace('#', '%23') | replace('?', '%3F') }}" loading="lazy" onload="this.classList.add('loaded')">
                        {% elif folder.count > 0 %}
                            <div class="video-placeholder-cover">
                                <span>ğŸ¬<br><span style="font-size: 0.8em;">Video/GIF</span></span>
                            </div>
                        {% endif %}
                        <div class="char-overlay"></div>
                        {% if folder.has_sub %}
                            <div class="mobile-folder-hint">ğŸ“‚</div>
                        {% endif %}
                    </div>
                    <div class="char-info">
                        <div class="char-name">{{ folder.name }}</div>
                        <div class="char-count">{{ folder.count }} é¡¹å†…å®¹</div>
                    </div>
                </a>
            {% endfor %}
        {% endif %}
        <template x-for="(file, index) in items" :key="index">
            <div class="grid-item" @click="openModal(index)">
                <template x-if="isImage(file)">
					<img :src="'/media/' + encodePath(file)" loading="lazy" @load="$el.classList.add('loaded')">
				</template>
				<template x-if="isVideo(file)">
					<video :src="'/media/' + encodePath(file)" muted loop playsinline
						   onmouseover="this.play()" onmouseout="this.pause()"
						   onloadeddata="this.classList.add('loaded')"></video>
				</template>

                <a :href="getFolderLink(file)"
                   class="grid-folder-btn"
                   x-show="!isFolderView && hasFolder(file)"
                   @click.stop>
                    ğŸ“‚ æ‰“å¼€å›¾é›†
                </a>

                <a :href="getFolderLink(file)"
                   class="mobile-jump-btn"
                   x-show="!isFolderView && hasFolder(file)"
                   @click.stop> ğŸ“‚
                </a>
            </div>
        </template>

        <div class="loader-trigger" x-intersect="typeof loadMore === 'function' && loadMore()">
            <span x-show="loading">â³ åŠ è½½ä¸­...</span>
            <span x-show="!hasMore && items.length > 0">--- End ---</span>
        </div>
    </div>

    <div class="modal" 
         x-show="modalOpen" 
         x-transition.opacity
         @keydown.escape.window="closeModal()"
         @keydown.arrow-right.window="next()"
         @keydown.arrow-left.window="prev()"
         @click="closeModal()">
         
        <div class="modal-close" @click.stop="closeModal()">&times;</div>
        
        <div style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;">
            <template x-if="modalOpen && currentItem">
                <div class="modal-media-container" @click.stop>
                    <div class="nav-hitbox prev-hitbox" @click.stop="prev()"></div>
                    <div class="nav-hitbox next-hitbox" @click.stop="next()"></div>

                    <template x-if="isImage(currentItem)">
						<img :src="'/media/' + encodePath(currentItem)" class="modal-content">
					</template>
					<template x-if="isVideo(currentItem)">
						<video :src="'/media/' + encodePath(currentItem)" class="modal-content" controls autoplay></video>
					</template>
                </div>
            </template>
        </div>
    </div>
</div>

<style>
.nav a.folder-btn {
    background-color: #005a9e;
    color: #fff;
    font-weight: bold;
}
.nav a {
    color: #eee;
    text-decoration: none;
    padding: 0 15px;
    font-size: 14px;
    height: 100%;
    display: flex;
    align-items: center;
    white-space: nowrap;
    background-color: transparent;
    transition: background-color 0.2s;
}
/* æ··æ’æ¨¡å¼ä¸‹çš„æ–‡ä»¶å¤¹å¡ç‰‡æ ·å¼ */
.folder-card-in-grid {
	text-decoration: none; display: block;
	border-radius: 4px; border: 1px solid #333;
	transition: transform 0.2s, border-color 0.2s;
}
.folder-card-in-grid:hover {
	transform: translateY(-5px); border-color: #0078d4;
	box-shadow: 0 5px 15px rgba(0,0,0,0.5); z-index: 10;
}
.folder-card-in-grid .char-cover { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
.folder-card-in-grid .char-cover img { width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 0.5s; }
.folder-card-in-grid .char-cover img.loaded { opacity: 1; }
.folder-card-in-grid .char-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 60%; background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); z-index: 1; }
.folder-card-in-grid .char-info { position: absolute; bottom: 0; left: 0; width: 100%; padding: 12px; box-sizing: border-box; z-index: 2; }
.folder-card-in-grid .char-name { color: #fff; font-weight: bold; font-size: 1.1em; text-shadow: 0 1px 2px rgba(0,0,0,1); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
.folder-card-in-grid .char-count { color: #ccc; font-size: 0.85em; }
.folder-card-in-grid .mobile-folder-hint { position: absolute; bottom: 60px; right: 10px; width: 32px; height: 32px; background-color: rgba(0, 0, 0, 0.65); backdrop-filter: blur(4px); border: 1px solid rgba(255, 255, 255, 0.25); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 20; }
.folder-card-in-grid .video-placeholder-cover { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #2a2a2a; color: #888; text-align: center; font-size: 1.2em; line-height: 1.2; }

@media (max-width: 768px) {
	.folder-card-in-grid .char-info { padding: 6px !important; }
	.folder-card-in-grid .char-name { font-size: 0.8em !important; margin-bottom: 2px !important; }
	.folder-card-in-grid .char-count { font-size: 0.7em !important; }
	.folder-card-in-grid .mobile-folder-hint { width: 24px; height: 24px; font-size: 14px; bottom: 45px; right: 4px; }
}

/* --- æœç´¢æ æ ·å¼ï¼ˆåŒæ­¥è‡ª explore/tagsï¼‰ --- */
.filter-bar { display: flex; align-items: center; gap: 8px; height: 32px; }
.filter-select { 
	background-color: #333; color: #eee; border: 1px solid #555; 
	padding: 0 24px 0 10px; border-radius: 4px; font-size: 12px; height: 100%;
	appearance: none; 
	background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
	background-repeat: no-repeat; background-position: right 5px center; background-size: 12px;
}
.search-wrapper { position: relative; height: 100%; }
.search-input { 
	background: #222; border: 1px solid #444; color: #fff; 
	padding: 0 10px; border-radius: 4px; width: 140px; height: 100%;
	transition: width 0.3s; font-size: 13px; box-sizing: border-box;
}
.search-input:focus { width: 200px; border-color: #0078d4; outline: none; }

.autocomplete-list { 
	position: absolute; top: 110%; left: 0; min-width: 100%; 
	background: #1e1e1e; border: 1px solid #444; border-radius: 4px; 
	max-height: 250px; overflow-y: auto; z-index: 2000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); 
	text-align: left; /* ä¿®æ­£å¯èƒ½è¢«å¤–éƒ¨ç»§æ‰¿çš„å±…ä¸­å¯¹é½ */
}
.suggestion-item { 
	padding: 8px 12px; border-bottom: 1px solid #333; cursor: pointer; 
	display: flex; justify-content: space-between; color: #ddd; font-size: 12px;
}
.suggestion-item.active, .suggestion-item:hover { background: #0078d4; color: #fff; }
.suggestion-item .count { color: #666; font-size: 0.9em; }

.search-btn {
	height: 100%; padding: 0 12px; background-color: #0078d4; color: white; border: none;
	border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;
	transition: background 0.2s, transform 0.1s; display: flex; align-items: center; justify-content: center;
	box-shadow: none !important;
}
.search-btn:hover { background-color: #0063b1; }
.search-btn:active { transform: scale(0.96); }

/* ç§»åŠ¨ç«¯é€‚é…ï¼šç¼©å°æœç´¢æ¡†å’Œéšè—åˆ†ç±»é€‰æ‹©ä»¥èŠ‚çœç©ºé—´ */
@media (max-width: 768px) {
	.filter-select { display: none; }
	.search-input { width: 100px; }
	.search-input:focus { width: 140px; }
	.filter-bar { margin-right: 5px !important; }
}
</style>

<script>
function galleryApp(apiUrl) {
    // é¢„å¤„ç†ï¼šç¡®ä¿ä¼ å…¥çš„ URL å­—ç¬¦ä¸²ä¸å¸¦å¤šä½™çš„å¼•å·ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ï¼‰
    const cleanApiUrl = typeof apiUrl === 'string' ? apiUrl.replace(/^["']|["']$/g, '') : '';

    return {
        items: [],
        page: 1,
        loading: false,
        hasMore: true,
        modalOpen: false,
        currentIndex: 0,
        baseApiUrl: cleanApiUrl,
        isFolderView: cleanApiUrl.includes('folder_data') {% if request.args.get('folder') and has_subfolders is defined and not has_subfolders %} || true {% endif %},
        seed: (cleanApiUrl.includes('/api/images') || cleanApiUrl.includes('/api/videos')) ? Date.now() : null,
		searchQuery: {{ request.args.get('q', '') | tojson }},
        searchType: 'tag',
        allTags: [],
        suggestions: [],
        selectedIndex: -1,
        
        showNav: true,
        lastScrollY: 0,
		
		init() {
            // ç»„ä»¶åŠ è½½æ—¶é¢„å–æ ‡ç­¾æ•°æ®ç”¨äºè¡¥å…¨
            this.loadTagsCache();
        },

        handleScroll() {
            if (this.modalOpen) return;
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
            this.showNav = !(currentScrollY > this.lastScrollY && currentScrollY > 50);
            this.lastScrollY = currentScrollY;
        },

        async loadMore() {
            if (this.loading || !this.hasMore) return;
            this.loading = true;
            try {
                const sep = this.baseApiUrl.includes('?') ? '&' : '?';
                let url = `${this.baseApiUrl}${sep}page=${this.page}`;
                if (this.seed) url += `&seed=${this.seed}`;
                
                const res = await fetch(url);
                if (!res.ok) throw new Error('Network response was not ok');
                const data = await res.json();
                
                if (data.files && data.files.length > 0) {
                    this.items.push(...data.files);
                    this.page++;
                    this.hasMore = data.has_more;
                } else {
                    this.hasMore = false;
                }
            } catch (e) {
                console.error("Gallery Load Error:", e);
                this.hasMore = false;
            } finally {
                this.loading = false;
            }
        },
		goBack() {
            // å¦‚æœæœ‰å†å²è®°å½•ï¼Œå¹¶ä¸”ä¸Šä¸€ä¸ªé¡µé¢æ˜¯æœ¬ç«™ï¼ˆé˜²æ­¢è·³è½¬åˆ°å¤–éƒ¨ç½‘ç«™ï¼‰
            if (window.history.length > 1 && document.referrer.includes(window.location.host)) {
                window.history.back(); // å®Œç¾é€€å›ä¸Šä¸€ä¸ªé¡µé¢ï¼Œä¿ç•™æ»šåŠ¨ä½ç½®
            } else {
                // å¦‚æœæ˜¯æ–°æ ‡ç­¾é¡µæ‰“å¼€ï¼Œæ²¡æœ‰å†å²è®°å½•ï¼Œæä¾›å…œåº•è·³è½¬
                if (this.baseApiUrl.includes('folder_data')) {
                    window.location.href = '/explore'; 
                } else if (window.location.search.includes('folder=')) {
                    // [æ ¸å¿ƒæ–°å¢] å¦‚æœæ˜¯æœç´¢ç»“æœçš„æ–‡ä»¶å¤¹å†…ï¼Œå…œåº•é€€å›å¯¹åº”çš„æœç´¢æ–‡ä»¶å¤¹é¡µ
                    const urlParams = new URLSearchParams(window.location.search);
                    const q = urlParams.get('q') || '';
                    window.location.href = '/search/folders?q=' + encodeURIComponent(q);
                } else {
                    window.location.href = '/';
                }
            }
        },
		
		// åŠ¨æ€åˆ¤å®šæœç´¢æç¤ºå ä½ç¬¦
        get searchPlaceholder() {
            if (window.location.pathname.startsWith('/folder/') || new URLSearchParams(window.location.search).get('folder')) {
                return "åœ¨æ­¤ç›®å½•ä¸‹æœç´¢...";
            }
            return "å…¨åº“æœç´¢...";
        },

        async loadTagsCache() {
            try {
                const res = await fetch('/api/tags/all');
                this.allTags = await res.json();
            } catch(e) { console.error("Tags cache error", e); }
        },

        handleInput() {
            this.selectedIndex = -1;
            const val = this.searchQuery;
            const parts = val.split(',');
            const lastPart = parts[parts.length - 1].trim().toLowerCase();

            if (lastPart.length < 1) {
                this.suggestions = [];
                return;
            }
            this.suggestions = this.allTags
                .filter(t => t.name.toLowerCase().includes(lastPart))
                .slice(0, 10);
        },

        navigateSuggestions(direction) {
            if (this.suggestions.length === 0) return;
            this.selectedIndex += direction;
            if (this.selectedIndex < 0) this.selectedIndex = this.suggestions.length - 1;
            else if (this.selectedIndex >= this.suggestions.length) this.selectedIndex = 0;
            
            this.$nextTick(() => {
                const activeEl = document.querySelector('.suggestion-item.active');
                if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
            });
        },

        handleEnter() {
            if (this.suggestions.length > 0 && this.selectedIndex >= 0) {
                this.selectSuggestion(this.suggestions[this.selectedIndex]);
            } else {
                this.performSearch();
            }
        },

        selectSuggestion(item) {
            let current = this.searchQuery;
            const parts = current.split(',');
            const newTagName = (item.type === 'char') ? `char:${item.name.replace('char:', '')}` : item.name;
            parts[parts.length - 1] = ' ' + newTagName; 
            this.searchQuery = parts.join(',') + ', ';
            
            this.suggestions = [];
            this.selectedIndex = -1;
            
            this.$nextTick(() => {
                const input = document.getElementById('gridSearchInput');
                if (input) {
                    input.focus();
                    const len = input.value.length;
                    input.setSelectionRange(len, len);
                }
            });
        },

        performSearch() {
            const queryRaw = this.searchQuery.trim().replace(/,$/, ''); 
            if (!queryRaw) return;
            
            let query = queryRaw;
            if (this.searchType === 'char' && !query.startsWith('char:')) {
                query = 'char:' + query;
            }

            // ã€æ ¸å¿ƒã€‘ï¼šåˆ¤æ–­æ˜¯å¦åœ¨æ–‡ä»¶å¤¹ä¸Šä¸‹æ–‡ä¸­ï¼Œä»¥ä¾¿ç»§æ‰¿ä½œè€…ç›®å½•è¿‡æ»¤
            let url = `/search?q=${encodeURIComponent(query)}`;
            const urlParams = new URLSearchParams(window.location.search);
            let folderContext = urlParams.get('folder');
            
            // å¦‚æœç”¨æˆ·æ˜¯åœ¨çœ‹å›¾çš„æ—¶å€™ç›´æ¥æœï¼ˆå¦‚ï¼š/folder/tsm2330 è·¯å¾„ä¸‹ï¼‰
            if (window.location.pathname.startsWith('/folder/')) {
                folderContext = decodeURIComponent(window.location.pathname.replace('/folder/', ''));
            }

            if (folderContext) {
                url += `&folder=${encodeURIComponent(folderContext)}`;
            }

            // grid é¡µé¢æœ¬èº«å°±æ˜¯æ˜¾ç¤ºå›¾ç‰‡æµï¼Œæ‰€ä»¥ç›´æ¥å¸¦å‚æ•°è·³è½¬å› /searchï¼ˆå›¾ç‰‡æµæ¨¡å¼ï¼‰
            window.location.href = url;
        },

        openModal(idx) {
            this.currentIndex = idx;
            this.modalOpen = true;
            this.showNav = false;
            document.body.style.overflow = 'hidden';
        },
        closeModal() {
            this.modalOpen = false;
            this.showNav = true;
            document.body.style.overflow = '';
        },
        get currentItem() { return this.items[this.currentIndex]; },
        
        next() {
            if (this.currentIndex < this.items.length - 1) {
                this.currentIndex++;
            } else if (this.hasMore) {
                this.loadMore().then(() => {
                    if (this.currentIndex < this.items.length - 1) this.currentIndex++;
                });
            }
        },
        prev() { 
            if (this.currentIndex > 0) this.currentIndex--; 
        },
        isImage(p) { return p ? /\.(png|jpg|jpeg|webp|bmp)$/i.test(p) : false; },
        isVideo(p) { return p ? /\.(mp4|webm|mov|mkv|gif)$/i.test(p) : false; },
        hasFolder(p) { return p && (p.includes('/') || p.includes('\\')); },
		getFolderLink(p) {
            if (!p) return '#';
            const norm = p.replace(/\\/g, '/');
            const lastSlash = norm.lastIndexOf('/');
            return lastSlash !== -1 ? '/folder/' + encodeURIComponent(norm.substring(0, lastSlash)) : '#';
        },
		
		encodePath(p) {
            if (!p) return '';
            return p.split('/').map(encodeURIComponent).join('/');
        },
        
        // ã€æ–°å¢ã€‘ï¼šæ™ºèƒ½åˆ‡æ¢åˆ°æ–‡ä»¶å¤¹æ¨¡å¼ï¼Œä¿ç•™ä½œè€…ç›®å½•è¿‡æ»¤
        toggleFolderMode() {
            const urlParams = new URLSearchParams(window.location.search);
            const q = urlParams.get('q');
            const folder = urlParams.get('folder');

            if (q) {
                let targetUrl = `/search/folders?q=${encodeURIComponent(q)}`;
                // å¦‚æœå½“å‰åœ¨ç‰¹å®šä½œè€…ç›®å½•ä¸‹æœç´¢ï¼Œå¿…é¡»å¸¦ä¸Š folder å‚æ•°
                if (folder) {
                    targetUrl += `&folder=${encodeURIComponent(folder)}`;
                }
                window.location.replace(targetUrl);
            } else {
                window.location.replace('/tags');
            }
        }
    }
}
</script>
{% endblock %}